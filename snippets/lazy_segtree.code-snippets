{
  "Lazy Segment Tree": {
    "prefix": "lazysegtree",
    "body": [
      "template<typename Node, typename Update>",
      "struct LazySGT {",
      "\tvector<Node> tree;",
      "\tvector<bool> lazy;",
      "\tvector<Update> updates;",
      "\tvector<long long> arr; // type may change",
      "\tlong long n;",
      "\tlong long s;",
      "\tLazySGT(vector<long long> &a) { // change if type updated",
      "\t\tarr = a;",
      "\t\tn = a.size();",
      "\t\ts = 1;",
      "\t\twhile(s < 4 * n){",
      "\t\t\ts = s << 1;",
      "\t\t}",
      "\t\ttree.resize(s); fill(tree.begin(), tree.end(), Node());",
      "\t\tlazy.resize(s); fill(lazy.begin(), lazy.end(), false);",
      "\t\tupdates.resize(s); fill(updates.begin(), updates.end(), Update());",
      "\t\tbuild(0, n - 1, 1);",
      "\t}",
      "\tLazySGT(long long _n) {",
      "\t\tn = _n;",
      "\t\ts = 1;",
      "\t\twhile(s < 4 * n){",
      "\t\t\ts = s << 1;",
      "\t\t}",
      "\t\ttree.resize(s); fill(tree.begin(), tree.end(), Node());",
      "\t\tlazy.resize(s); fill(lazy.begin(), lazy.end(), false);",
      "\t\tupdates.resize(s); fill(updates.begin(), updates.end(), Update());",
      "\t}",
      "\tvoid build(long long start, long long end, long long index) { // Never change this",
      "\t\tif (start == end)   {",
      "\t\t\ttree[index] = Node(arr[start]);",
      "\t\t\treturn;",
      "\t\t}",
      "\t\tlong long mid = (start + end) / 2;",
      "\t\tbuild(start, mid, 2 * index);",
      "\t\tbuild(mid + 1, end, 2 * index + 1);",
      "\t\ttree[index].merge(tree[2 * index], tree[2 * index + 1]);",
      "\t}",
      "\tvoid pushdown(long long index, long long start, long long end){",
      "\t\tif(lazy[index]){",
      "\t\t\tlong long mid = (start + end) / 2;",
      "\t\t\tapply(2 * index, start, mid, updates[index]);",
      "\t\t\tapply(2 * index + 1, mid + 1, end, updates[index]);",
      "\t\t\tupdates[index] = Update();",
      "\t\t\tlazy[index] = 0;",
      "\t\t}",
      "\t}",
      "\tvoid apply(long long index, long long start, long long end, Update& u){",
      "\t\tif(start != end){",
      "\t\t\tlazy[index] = 1;",
      "\t\t\tupdates[index].combine(u, start, end);",
      "\t\t}",
      "\t\tu.apply(tree[index], start, end);",
      "\t}",
      "\tvoid update(long long start, long long end, long long index, long long left, long long right, Update& u) {  // Never Change this",
      "\t\tif(start > right || end < left)",
      "\t\t\treturn;",
      "\t\tif(start >= left && end <= right){",
      "\t\t\tapply(index, start, end, u);",
      "\t\t\treturn;",
      "\t\t}",
      "\t\tpushdown(index, start, end);",
      "\t\tlong long mid = (start + end) / 2;",
      "\t\tupdate(start, mid, 2 * index, left, right, u);",
      "\t\tupdate(mid + 1, end, 2 * index + 1, left, right, u);",
      "\t\ttree[index].merge(tree[2 * index], tree[2 * index + 1]);",
      "\t}",
      "\tNode query(long long start, long long end, long long index, long long left, long long right) { // Never change this",
      "\t\tif (start > right || end < left)",
      "\t\t\treturn Node();",
      "\t\tif (start >= left && end <= right){",
      "\t\t\treturn tree[index];",
      "\t\t}",
      "\t\tpushdown(index, start, end);",
      "\t\tlong long mid = (start + end) / 2;",
      "\t\tNode l, r, ans;",
      "\t\tl = query(start, mid, 2 * index, left, right);",
      "\t\tr = query(mid + 1, end, 2 * index + 1, left, right);",
      "\t\tans.merge(l, r);",
      "\t\treturn ans;",
      "\t}",
      "\tvoid make_update(long long left, long long right, long long val) {  // pass in as many parameters as required",
      "\t\tUpdate new_update = Update(val); // may change",
      "\t\tupdate(0, n - 1, 1, left, right, new_update);",
      "\t}",
      "\tNode make_query(long long left, long long right) {",
      "\t\treturn query(0, n - 1, 1, left, right);",
      "\t}",
      "};",
      "",
      "struct Node1 {",
      "\tlong long val; // may change",
      "\tNode1() { // Identity element",
      "\t\tval = 0;    // may change",
      "\t}",
      "\tNode1(long long p1) {  // Actual Node",
      "\t\tval = p1; // may change",
      "\t}",
      "\tvoid merge(Node1 &l, Node1 &r) { // Merge two child nodes",
      "\t\tval = l.val + r.val;  // may change",
      "\t}",
      "};",
      "",
      "struct Update1 {",
      "\tlong long val; // may change",
      "\tUpdate1(){ // Identity update",
      "\t\tval = 0;",
      "\t}",
      "\tUpdate1(long long val1) { // Actual Update",
      "\t\tval = val1;",
      "\t}",
      "\tvoid apply(Node1 &a, int start, int end) { // apply update to given node",
      "\t\ta.val = val * (end - start + 1); // may change",
      "\t}",
      "\tvoid combine(Update1& new_update, int start, int end){",
      "\t\tval = new_update.val;",
      "\t}",
      "};"
    ],
    "description": "Lazy Segment Tree"
  }
}
